"""Tests for the network module."""

import StringIO
import unittest

# Third-party modules.
import mock
import netifaces

# Module under test.
import network

_FAKE_ROUTE_TABLE_GOOD = """
Iface   Destination     Gateway         Flags   RefCnt  Use
eth0    01020304        00000000        0001    0       0       0
eth0    0000FEA9        00000000        0001    0       0       1002
eth0    00000000        02030405        0003    0       0       0
""".strip()
# This route table is "bad" because it is missing a default route, i.e. there
# is no Destination address of "00000000".
_FAKE_ROUTE_TABLE_BAD = """
Iface   Destination     Gateway         Flags   RefCnt  Use
eth0    01020304        00000000        0001    0       0       0
eth0    0000FEA9        00000000        0001    0       0       1002
""".strip()

_FAKE_ARP_CACHE_GOOD = """
IP address       HW type     Flags       HW address            Mask     Device
5.4.3.2          0x1         0x2         00:11:22:33:44:55     *        eth0
""".strip()
# This arp cache is "bad" releative to _FAKE_ROUTE_TABLE_GOOD. The gateway IP
# from the route table is not in this arp cache.
_FAKE_ARP_CACHE_BAD = """
IP address       HW type     Flags       HW address            Mask     Device
5.4.3.3          0x1         0x2         00:11:22:33:44:55     *        eth0
""".strip()


class NetworkTest(unittest.TestCase):
    """Tests for the network module."""

    @mock.patch.object(network, '_get_network_interfaces')
    @mock.patch.object(network, '_get_interface_addresses')
    def test_get_local_mac(self, mock_interface_addresses,
                           mock_network_interfaces):
        expected_value = '00:11:22:33:44:55'
        mock_network_interfaces.return_value = ['lo', 'eth0']
        mock_interface_addresses.return_value = {
            netifaces.AF_LINK: [{'addr': expected_value}]
        }

        returned_value = network.get_local_mac()

        self.assertEqual(expected_value, returned_value)

    @mock.patch.object(network, '_get_network_interfaces')
    @mock.patch.object(network, '_get_interface_addresses')
    def test_get_local_mac_when_raises_too_few_interfaces(
            self, mock_interface_addresses, mock_network_interfaces):
        """Force too few interfaces with an empty value for interface addresses."""
        mock_network_interfaces.return_value = ['eth0']
        mock_interface_addresses.return_value = {}

        with self.assertRaises(network.TooFewInterfaces):
            network.get_local_mac()

    @mock.patch.object(network, '_get_network_interfaces')
    @mock.patch.object(network, '_get_interface_addresses')
    def test_get_local_mac_when_raises_too_many_interfaces(
            self, mock_interface_addresses, mock_network_interfaces):
        """Define multiple interfaces to force too many interfaces."""
        mock_network_interfaces.return_value = ['eth0', 'eth1']
        mock_interface_addresses.side_effect = [
            {netifaces.AF_LINK: [{'addr': '00:11:22:33:44:55'}]},
            {netifaces.AF_LINK: [{'addr': '10:11:22:33:44:55'}]}
        ]

        with self.assertRaises(network.TooManyInterfaces):
            network.get_local_mac()

    def test_get_uplink_mac_impl(self):
        routefile = StringIO.StringIO(_FAKE_ROUTE_TABLE_GOOD)
        arpfile = StringIO.StringIO(_FAKE_ARP_CACHE_GOOD)
        expected_uplink_mac = '00:11:22:33:44:55'

        returned_uplink_mac = network.get_uplink_mac_impl(routefile, arpfile)

        self.assertEqual(expected_uplink_mac, returned_uplink_mac)

    def test_get_uplink_mac_impl_raises_uplink_mac_not_found(self):
        routefile = StringIO.StringIO(_FAKE_ROUTE_TABLE_GOOD)
        arpfile = StringIO.StringIO(_FAKE_ARP_CACHE_BAD)

        with self.assertRaises(network.UplinkMACNotFound):
            network.get_uplink_mac_impl(routefile, arpfile)

    def test_get_uplink_mac_impl_raises_no_default_route(self):
        routefile = StringIO.StringIO(_FAKE_ROUTE_TABLE_BAD)
        arpfile = StringIO.StringIO(_FAKE_ARP_CACHE_GOOD)

        with self.assertRaises(network.NoDefaultRoute):
            network.get_uplink_mac_impl(routefile, arpfile)


if __name__ == '__main__':
    unittest.main()
