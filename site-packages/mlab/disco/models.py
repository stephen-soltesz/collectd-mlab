"""Functions to identify switch models and their unique OIDs."""

import collections
import copy
import yaml


class Error(Exception):
    """Base error class for models."""
    pass


class UnknownSwitchModel(Error):
    """The switch model is not known."""
    pass


class UnsupportedOidName(Error):
    """Oid name is not supported."""
    pass


class BadConfiguration(Error):
    """An error occurred while reading configuration."""
    pass


class NotInitialized(Error):
    """The occurred while reading configuration."""
    pass


def load_switch_config(filename, config=None):
    """Loads the OIDs for model_name from the configuration in config_fd.

    For example:

        models:
            foo:
                qbridge: True
                pattern: FooDevice

        oids:
            default:
                discards:
                    in: RFC1213-MIB::ifInDiscards.{ifIndex}
                    out: RFC1213-MIB::ifOutDiscards.{ifIndex}

            foo:
                discards:
                    out: SPECIAL-MIB::ifFancyDiscards.{ifIndex}

    Would return:

        {'models':
            {'foo':
                {'qbridge': True,
                 'pattern': 'FooDevice',
                },
            },
         'oids':
            {'default':
                {'discards':
                    {'in': 'RFC1213-MIB::ifInDiscards.{ifIndex}',
                     'out': 'RFC1213-MIB::ifOutDiscards.{ifIndex}',
                    }
                }
             'foo':
                {'discards':
                    {'in': 'RFC1213-MIB::ifInDiscards.{ifIndex}',
                     'out': 'SPECIAL-MIB::ifFancyDiscards.{ifIndex}',
                    }
                }
            }

    Notice that foo.discards value includes the default.discards.in value, and
    foo.discardsout overrides the default.discards.out value.

    Args:
        filename: str, full path of configuration file.
        config: dict or None, a pre-parsed configuration; if provided, filename
            is ignored. If None, the parameter is ignored and config is read
            from filename.

    Returns:
        dict, complete model and OID switch configuraion.

    Raises:
        BadConfiguration: found a bad configuration.
    """
    if config is None:
        with open(filename) as config_fd:
            config = yaml.load(config_fd)

    if 'models' not in config:
        raise BadConfiguration('Missing "models" section of configuration.')

    for model_name in config['models']:
        model_keys = config['models'][model_name].keys()
        if 'qbridge' not in model_keys or 'pattern' not in model_keys:
            raise BadConfiguration(
                'Missing "qbridge" or "pattern" section in model: %s.' %
                model_name)

    if 'oids' not in config:
        raise BadConfiguration('Missing "oids" section of configuration.')

    oid_config = config['oids']
    if 'default' not in oid_config:
        raise BadConfiguration('Missing "default" section in "oids" section.')

    # Populate the OID values.
    for model_name in config['models']:
        model_oids = copy.deepcopy(oid_config['default'])
        if model_name in oid_config:
            # Update the default with model-specific configuration.
            _deep_update(model_oids, oid_config[model_name])
        # Save the full model-specific configuration.
        oid_config[model_name] = model_oids

    return config


class SwitchConfig(object):
    """Configuration interface for switch models.

    Call set_canonical_name first to enable all other methods.
    """

    def __init__(self, config):
        """Initializes the object.

        Args:
          config: dict, a full model configuration as returned by
              load_switch_config.
        """
        self._model_config = config['models']
        self._oid_config = config['oids']
        self._model_name = None

    def get_model_config(self, sysdescr):
        """Returns a model configuration based on the switch model.

        Args:
            sysdescr: str, the value returned for the sysDescr.0 OID.

        Returns:
            Model, a switch configuration based on the switch model.

        Raises:
            UnknownSwitchModel: could not identify the model corresponding to
                sysdescr.
        """
        for model_name, config in self._model_config.iteritems():
            if config['pattern'] in sysdescr:
                return Model(model_name, self._model_config[model_name],
                             self._oid_config[model_name])
        raise UnknownSwitchModel('Unknown switch model: %s' % sysdescr)


class Model(object):
    """Accesses configuration information for a specific switch model."""

    def __init__(self, model_name, model_config, oid_config):
        """."""
        self._model_name = model_name
        self._model_config = model_config
        self._oid_config = oid_config

    @property
    def model_name(self):
        """Returns the canonical switch model name."""
        return self._model_name

    def supports_qbridge(self):
        """Returns whether the model supports Q-BRIDGE MIBs.

        Returns:
            bool, True if the this model supports Q-BRIDGE OIDs, False
                otherwise.
        """
        return self._model_config['qbridge']

    def oid_names(self):
        """Returns list of OID names in the model OID configuration."""
        return self._oid_config.keys()

    def lookup_oids(self, oid_name, port):
        """Returns the input and output OIDs for oid_name on port.

        Args:
          oid_name: str, a supported oid_name; one returned by
              SwitchConfig.oid_names.
          port: str, the interface index number as returned by
              DiscoverySession.auto_discover_ports.

        Returns:
          tuple of (str, str), containing the input and output OID for oid_name.

        Raises:
          UnsupportedOidName: the oid_name is not supported.
        """
        try:
            oid_config = self._oid_config[oid_name]
        except KeyError as err:
            raise UnsupportedOidName('Unknown OID name: %s' % err)

        try:
            return (oid_config['in'].format(ifIndex=port),
                    oid_config['out'].format(ifIndex=port))
        except KeyError as err:
            raise BadConfiguration(
                'Expected "in" and "out" keys in oid_config: %s' % oid_config)


def _deep_update(dest, source):
    """Performs a deep dict update of dest with source.

    Note that dest is modified in place.

    Args:
        dest: dict, the destination to update.
        source: dict, the source of new information.

    Returns:
        dict, dest updated with the contents of source.
    """
    for key, value in source.iteritems():
        if isinstance(value, collections.Mapping):
            dest[key] = _deep_update(dest.get(key, {}), value)
        else:
            dest[key] = source[key]
    return dest
