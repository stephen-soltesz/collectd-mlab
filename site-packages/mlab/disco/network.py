"""Utility methods for accessing local network information."""

import netifaces


class Error(Exception):
    """Base error class for network module."""
    pass


class NoDefaultRoute(Error):
    """Failed to find a default route in the routing table."""
    pass


class TooManyInterfaces(Exception):
    """Too many physical interfaces were found."""
    pass


class TooFewInterfaces(Exception):
    """Too few physical interfaces were found."""
    pass


class UplinkMACNotFound(Exception):
    """Could not discover a MAC address on switch uplink port."""
    pass


_ARP_FILENAME = '/proc/net/arp'
_LOOPBACK = 'lo'
_ROUTE_FILENAME = '/proc/net/route'
_ROUTE_DEFAULT_ADDR = '00000000'


def get_local_mac():
    """Discovers the local network interface MAC address.

    Returns:
      str, local MAC address in six-byte hex form: 00:00:00:00:00:00.

    Raises:
      TooManyInterfaces, if more than one MAC address is discovered.
      TooFewInterfaces, if no MAC addresses are discovered.
    """
    macs = {}

    for iface in _get_network_interfaces():
        if iface == _LOOPBACK:
            continue
        addrs = _get_interface_addresses(iface)
        if netifaces.AF_LINK in addrs:
            macs[addrs[netifaces.AF_LINK][0]['addr']] = 1

    if not macs:
        raise TooFewInterfaces('Could not find any physical interfaces.')

    if len(macs) > 1:
        raise TooManyInterfaces(
            'Can only handle a single physical interface: %s' % macs)

    return macs.keys()[0]


def get_uplink_mac():
    """Wraps get_uplink_mac_impl.

    Returns:
      str, a MAC address in six-byte hex form: 00:00:00:00:00:00

    Raises:
      IOError, if the routing table or arp cache files cannot be opened.
      NoDefaultRoute, if no default route is found in routing table.
      UplinkMACNotFound, if a MAC address is not found in the arp cache.
    """
    routefile = open(_ROUTE_FILENAME, 'r')
    arpfile = open(_ARP_FILENAME, 'r')
    return get_uplink_mac_impl(routefile, arpfile)


def get_uplink_mac_impl(routefile, arpfile):
    """Discovers a MAC address associated with the switch uplink port.

    Get uplink MAC uses the current routing table and ARP cache.

    Args:
      routefile: file, readable file object containing a routing table.
      arpfile: file, readable file object containing an arp cache.

    Returns:
      str, a MAC address in six-byte hex form: 00:00:00:00:00:00

    Raises:
      NoDefaultRoute, if no default route is found in routing table.
      UplinkMACNotFound, if a MAC address is not found in the arp cache.
    """
    route_ip = _parse_default_route(routefile)
    arp = _parse_arpcache(arpfile)
    if route_ip not in arp:
        raise UplinkMACNotFound(
            'Default gateway IP not found in arp cache: %s' % route_ip)
    return arp[route_ip]


def _hexip_to_decip(hex_ip):
    """Converts a hexidecimal IP address to decimal form."""
    fields = [hex_ip[i:i + 2] for i in range(0, len(hex_ip), 2)]
    dec_fields = [str(int(v, 16)) for v in fields]
    dec_fields.reverse()
    return '.'.join(dec_fields)


def _parse_default_route(routefile):
    """Parses the system routing table, and returns the default gateway IP.

    Example:
      $ cat /proc/net/route
      Iface   Destination   Gateway   Flags   RefCnt  Use     Metric  ...
      eth0    00000000      8180E417  0003    0       0       0       ...

    Args:
      routefile: file, readable file object containing a routing table.

    Returns:
      str, the decimal form of the destination IP address for the first default
          gateway.

    Raises:
      NoDefaultRoute, if there is no route entry with hex address "00000000".
    """
    cache = routefile.readlines()
    # Skip the header.
    for line in cache[1:]:
        fields = line.split()
        if fields[1] == _ROUTE_DEFAULT_ADDR:
            return _hexip_to_decip(fields[2])
    raise NoDefaultRoute('No default route found!')


def _parse_arpcache(arpfile):
    """Parses the system arp cache, and returns a dict mapping IPs to MACs.

    Example:
      $ cat /proc/net/arp
      IP address       HW type   Flags    HW address          Mask   Device
      23.228.128.130   0x1       0x2      78:19:f7:86:44:81   *      eth0

    Args:
      arpfile: file, readable file object containing an arp cache.

    Returns:
      dict of str, where keys are IP addresses and values are MAC addresses.
    """
    cache = arpfile.readlines()
    arp = {}
    # Skip the header.
    for line in cache[1:]:
        fields = line.split()
        arp[fields[0]] = fields[3]
    return arp


def _get_network_interfaces():
    """Wrapper for netifaces.interfaces function."""
    return netifaces.interfaces()


def _get_interface_addresses(iface):
    """Wrapper for netifaces.ifaddresses function."""
    return netifaces.ifaddresses(iface)
