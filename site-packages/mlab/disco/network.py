"""Utility methods for accessing local network information."""

import netifaces


class Error(Exception):
    """Base error class for network module."""
    pass


class NoDefaultRoute(Error):
    """Failed to find a default route in the routing table."""
    pass


class TooManyInterfaces(Exception):
    """Too many physical interfaces were found."""
    pass


class TooFewInterfaces(Exception):
    """Too few physical interfaces were found."""
    pass


class UplinkMACNotFound(Exception):
    """Could not discover a MAC address on switch uplink port."""
    pass

# Path to the ARP cache file under the /proc filesystem.
_ARP_FILENAME = '/proc/net/arp'

# Default name for the loopback interface.
_LOOPBACK = 'lo'

# Path to the routing table file under the /proc filesystem.
_ROUTE_FILENAME = '/proc/net/route'

# The default IPv4 route address in hexadecimal form.
_ROUTE_DEFAULT_ADDR = '00000000'


def get_local_mac():
    """Discovers the local network interface MAC address.

    Returns:
      str, local MAC address in six-byte hex form: 00:00:00:00:00:00.

    Raises:
      TooManyInterfaces: if more than one MAC address is discovered.
      TooFewInterfaces: if no MAC addresses are discovered.
    """
    macs = set()

    for iface in _get_network_interfaces():
        if iface == _LOOPBACK:
            continue
        addrs = _get_interface_addresses(iface)
        # AF_LINK is a link layer interface, i.e. the physical interface.
        if netifaces.AF_LINK in addrs:
            macs.add(addrs[netifaces.AF_LINK][0]['addr'])

    if not macs:
        raise TooFewInterfaces('Could not find any physical interfaces.')

    if len(macs) > 1:
        raise TooManyInterfaces(
            'Multiple physical interfaces are not supported, found: %s' % macs)

    return macs.pop()


def get_uplink_mac():
    """Wraps get_uplink_mac_impl.

    Returns:
      str, a MAC address in six-byte hex form: 00:00:00:00:00:00

    Raises:
      IOError: if the routing table or ARP cache files cannot be opened.
      NoDefaultRoute: if no default route is found in routing table.
      UplinkMACNotFound: if a MAC address is not found in the ARP cache.
    """
    with open(_ROUTE_FILENAME) as route_file:
        with open(_ARP_FILENAME) as arp_file:
            return get_uplink_mac_impl(route_file, arp_file)


def get_uplink_mac_impl(route_file, arp_file):
    """Discovers a MAC address associated with the switch uplink port.

    Multiple MACs may be associated with the switch uplink port. We look
    specifically for the MAC associated with the IPv4 address of the default
    gateway which is should always be present.

    Args:
      route_file: file, readable file object containing a routing table.
      arp_file: file, readable file object containing an ARP cache.

    Returns:
      str, a MAC address in six-byte hex form: 00:00:00:00:00:00

    Raises:
      NoDefaultRoute: if no default route is found in routing table.
      UplinkMACNotFound: if a MAC address is not found in the ARP cache.
    """
    route_ip = _parse_default_route(route_file)
    arp = _parse_arpcache(arp_file)
    try:
        return arp[route_ip]
    except KeyError:
        raise UplinkMACNotFound(
            'Default gateway IP not found in ARP cache: %s' % route_ip)


def _hexip_to_decip(hex_ip):
    """Converts a hexidecimal IP address to decimal form."""
    fields = [hex_ip[i:i + 2] for i in range(0, len(hex_ip), 2)]
    dec_fields = [str(int(v, 16)) for v in fields]
    dec_fields.reverse()
    return '.'.join(dec_fields)


def _parse_default_route(route_file):
    """Parses the system routing table, and returns the default gateway IP.

    Example:
      $ cat /proc/net/route
      Iface   Destination   Gateway   Flags   RefCnt  Use     Metric  ...
      eth0    00000000      8180E417  0003    0       0       0       ...

    Args:
      route_file: file, readable file object containing a routing table.

    Returns:
      str, the decimal form of the destination IP address for the first default
          gateway.

    Raises:
      NoDefaultRoute: if there is no route entry with hex address "00000000".
    """
    cache = route_file.readlines()
    # Skip the header.
    for line in cache[1:]:
        fields = line.split()
        if fields[1] == _ROUTE_DEFAULT_ADDR:
            return _hexip_to_decip(fields[2])
    raise NoDefaultRoute('No default route found!')


def _parse_arpcache(arp_file):
    """Parses the system ARP cache, and returns a dict mapping IPs to MACs.

    Example:
      $ cat /proc/net/arp
      IP address       HW type   Flags    HW address          Mask   Device
      23.228.128.130   0x1       0x2      78:19:f7:86:44:81   *      eth0

    Args:
      arp_file: file, readable file object containing an ARP cache.

    Returns:
      dict of str, where keys are IP addresses and values are MAC addresses.
    """
    cache = arp_file.readlines()
    arp = {}
    # Skip the header.
    for line in cache[1:]:
        fields = line.split()
        arp[fields[0]] = fields[3]
    return arp


def _get_network_interfaces():
    """Wrapper for netifaces.interfaces function."""
    return netifaces.interfaces()


def _get_interface_addresses(iface):
    """Wrapper for netifaces.ifaddresses function."""
    return netifaces.ifaddresses(iface)
