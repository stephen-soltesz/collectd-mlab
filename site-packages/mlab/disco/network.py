"""Utility methods for accessing local network information."""

import netifaces


class Error(Exception):
    """Base error class for network module."""
    pass


class NoDefaultRoute(Error):
    """Failed to find a default route in the routing table."""
    pass


class TooManyInterfaces(Exception):
    """Too many physical interfaces were found."""
    pass


class TooFewInterfaces(Exception):
    """Too few physical interfaces were found."""
    pass


class UplinkMACNotFound(Exception):
    """Could not discover a MAC address on switch uplink port."""
    pass

# Path to the ARP cache file under the /proc filesystem.
_ARP_FILENAME = '/proc/net/arp'

# Default name for the loopback interface.
_LOOPBACK = 'lo'

# Path to the routing table file under the /proc filesystem.
_ROUTE_FILENAME = '/proc/net/route'

# The default IPv4 route address as reported by /proc/net/route.
_ROUTE_DEFAULT_ADDR = '00000000'


def get_local_mac():
    """Discovers the local network interface MAC address.

    Returns:
      str, local MAC address in six-byte hex form: 00:00:00:00:00:00.

    Raises:
      TooManyInterfaces: more than one MAC address is discovered.
      TooFewInterfaces: no MAC addresses are discovered.
    """
    macs = set()

    for iface in netifaces.interfaces():
        if iface == _LOOPBACK:
            continue
        addrs = netifaces.ifaddresses(iface)
        # AF_LINK is a link layer interface, i.e. the physical interface.
        if netifaces.AF_LINK in addrs:
            macs.add(addrs[netifaces.AF_LINK][0]['addr'])

    if not macs:
        raise TooFewInterfaces('Could not find any physical interfaces.')

    if len(macs) > 1:
        raise TooManyInterfaces(
            'Multiple physical interfaces are not supported, found: %s' % macs)

    return macs.pop()


def get_uplink_mac(route_lines=None, arp_lines=None):
    """Discovers a MAC address associated with the switch uplink port.

    Multiple MACs may be associated with the switch uplink port. We look
    specifically for the MAC associated with the IPv4 address of the default
    gateway which should always be present.

    Args:
      route_lines: None or list of str, lines read from a routing table. If
          None, read lines from the system routing table.
      arp_lines: None or list of str, lines read from an ARP cache. If None,
          read lines from the system ARP cache.

    Returns:
      str, a MAC address in six-byte hex form: 00:00:00:00:00:00

    Raises:
      IOError: the routing table or ARP cache files cannot be opened.
      NoDefaultRoute: no default route is found in routing table.
      UplinkMACNotFound: a MAC address is not found in the ARP cache.
    """
    if route_lines is None:
        with open(_ROUTE_FILENAME) as route_file:
            route_lines = route_file.readlines()

    if arp_lines is None:
        with open(_ARP_FILENAME) as arp_file:
            arp_lines = arp_file.readlines()

    route_ip = _parse_default_route(route_lines)
    ip_to_mac = _parse_arpcache(arp_lines)
    try:
        return ip_to_mac[route_ip]
    except KeyError:
        raise UplinkMACNotFound(
            'Default gateway IP not found in ARP cache: %s' % route_ip)


def _hexip_to_decip(hex_ip):
    """Converts a hexadecimal IPv4 address to quad-dotted form.

    Args:
      hex_ip: str, zero padded, network order, hexadecimal format IPv4 address.

    Returns:
      str, quad-dotted format IPv4 address.
    """
    fields = [hex_ip[i:i + 2] for i in range(0, len(hex_ip), 2)]
    dec_fields = [str(int(v, 16)) for v in fields]
    dec_fields.reverse()
    return '.'.join(dec_fields)


# TODO: Replace with version 0.10+ netifaces.gateways() function when possible.
def _parse_default_route(route_lines):
    """Parses a system routing table file, and returns the default gateway IP.

    Example:
      $ cat /proc/net/route
      Iface   Destination   Gateway   Flags   RefCnt  Use     Metric  ...
      eth0    00000000      8180E417  0003    0       0       0       ...

    Args:
      route_lines: list of str, lines read from a routing table.

    Returns:
      str, quad-dotted format of the destination IP address for the first
          default gateway.

    Raises:
      NoDefaultRoute: there is no route entry with default route address.
    """
    # Skip the header.
    for line in route_lines[1:]:
        fields = line.split()
        if fields[1] == _ROUTE_DEFAULT_ADDR:
            return _hexip_to_decip(fields[2])
    raise NoDefaultRoute('No default route found!')


def _parse_arpcache(arp_lines):
    """Parses an ARP cache file, and returns a dict mapping IPs to MACs.

    Example:
      $ cat /proc/net/arp
      IP address       HW type   Flags    HW address          Mask   Device
      23.228.128.130   0x1       0x2      78:19:f7:86:44:81   *      eth0

    Args:
      arp_lines: list of str, lines from an ARP cache.

    Returns:
      dict of str, where keys are IP addresses and values are MAC addresses.
          e.g. {'23.228.128.130': '78:19:f7:86:44:81'}
    """
    ip_to_mac = {}
    # Skip the header.
    for line in arp_lines[1:]:
        fields = line.split()
        ip_to_mac[fields[0]] = fields[3]
    return ip_to_mac
